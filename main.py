
import os
import json
import asyncio
import threading
from telethon.sync import TelegramClient
from telethon.errors import SessionPasswordNeededError
from getpass import getpass
from datetime import datetime
import re
from tqdm import tqdm

CONFIG_FILE = 'config.json'
CACHE_FILE = 'file_cache.json'
skip_download = False
concurrent_downloads = 1  # padr√£o

def monitorar_pular_download():
    global skip_download
    print("\n‚è≠Ô∏è  Pressione 'p' e Enter a qualquer momento para pular o download atual.")
    while True:
        tecla = input()
        if tecla.strip().lower() == 'p':
            skip_download = True

def carregar_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    return {}

def salvar_config(config):
    with open(CONFIG_FILE, 'w') as f:
        json.dump(config, f, indent=4)

def entrada_config(campo, texto, obrigatorio=False, padrao=None):
    while True:
        valor = input(f"{texto} [{config.get(campo, padrao) or 'n√£o definido'}]: ").strip()
        if valor:
            config[campo] = valor
            return valor
        elif config.get(campo):
            return config[campo]
        elif padrao is not None:
            config[campo] = padrao
            return padrao
        elif not obrigatorio:
            return ''
        else:
            print("‚ùó Campo obrigat√≥rio. Tente novamente.")

def combinar_nome(nome_arquivo, termos):
    if not termos:
        return True
    termos = termos.lower().split()
    return all(t in nome_arquivo.lower() for t in termos)

async def levantar_arquivos(client, group_username):
    arquivos = []
    count = 0
    inicio = datetime.now()
    try:
        async for msg in client.iter_messages(group_username):
            if msg.file and msg.file.name:
                arquivos.append({'id': msg.id, 'name': msg.file.name})
            count += 1
            if count % 100 == 0:
                duracao = datetime.now() - inicio
                print(f"üîÑ Lidas {count} mensagens... Tempo: {str(duracao).split('.')[0]}")
    except KeyboardInterrupt:
        print("\n‚õî Busca interrompida pelo usu√°rio.")
        return []
    print(f"\nüì¶ Total de arquivos listados: {len(arquivos)}")

    with open(CACHE_FILE, 'w') as f:
        json.dump(arquivos, f, indent=2)
        print(f"üíæ Levantamento salvo em cache: {CACHE_FILE}")
    return arquivos

async def baixar_arquivo(client, arq, group_username, downloads_dir):
    global skip_download
    try:
        if skip_download:
            print(f"‚è≠Ô∏è  {arq['name']} foi pulado.")
            skip_download = False
            return

        file_path = os.path.join(downloads_dir, arq['name'])

        if os.path.exists(file_path):
            print(f"‚úÖ {arq['name']} j√° existe. Pulando download.")
            return

        msg = await client.get_messages(group_username, ids=arq['id'])
        print(f"‚¨áÔ∏è  Baixando: {arq['name']}")

        # Barra de progresso com tqdm
        with tqdm(total=msg.file.size or 0, unit='B', unit_scale=True, desc=arq['name'][:40]) as bar:
            def progresso(bytes_enviados, tamanho_total):
                bar.total = tamanho_total
                bar.update(bytes_enviados - bar.n)

            await msg.download_media(file_path, progress_callback=progresso)

    except Exception as e:
        print(f"‚ùå Erro ao baixar {arq['name']}: {e}")

async def main():
    global config, concurrent_downloads
    config = carregar_config()

    print("üõ†Ô∏è  Cadastro do aplicativo no Telegram")
    print("Antes de prosseguir, voc√™ j√° preencheu o formul√°rio de app em https://my.telegram.org/apps?")
    pronto = input("Digite S (ou Enter) para sim ou N para sair: ").strip().lower()
    if pronto != 's' and pronto != '':
        print("‚ùå Voc√™ precisa concluir o cadastro antes de continuar.")
        return

    print("\n‚úÖ Cadastro confirmado. Vamos coletar os dados necess√°rios:")

    api_id = entrada_config("api_id", "Digite o API ID", obrigatorio=True)
    api_hash = entrada_config("api_hash", "Digite o API HASH", obrigatorio=True)
    phone = entrada_config("phone", "Digite seu telefone (com DDI)", obrigatorio=True)
    group_username = entrada_config("group_username", "Nome do grupo ou canal (sem @)", obrigatorio=True)

    downloads_dir = entrada_config(
        "downloads_dir",
        "Diret√≥rio de destino dos downloads",
        padrao=os.path.join(os.getcwd(), "downloads")
    )

    if not os.path.exists(downloads_dir):
        os.makedirs(downloads_dir)
        print(f"üìÅ Diret√≥rio '{downloads_dir}' criado.")

    # Quantidade de downloads simult√¢neos
    valor = input(f"Quantos downloads simult√¢neos por vez? (0 = ilimitado, Enter para manter {config.get('concurrent_downloads', 1)}) [1]: ").strip()
    if valor.isdigit():
        concurrent_downloads = int(valor)
        config['concurrent_downloads'] = concurrent_downloads
    elif valor == '':
        concurrent_downloads = int(config.get('concurrent_downloads', 1))
    else:
        concurrent_downloads = 1

    salvar_config(config)

    print("\nüîê Conectando ao Telegram...\n")
    client = TelegramClient('session_name', int(api_id), api_hash)
    await client.start(phone)

    if not await client.is_user_authorized():
        try:
            await client.send_code_request(phone)
            code = input('Digite o c√≥digo que voc√™ recebeu: ')
            await client.sign_in(phone, code)
        except SessionPasswordNeededError:
            pw = getpass('Senha em duas etapas: ')
            await client.sign_in(password=pw)

    print(f"\n‚úÖ Conectado. Acessando grupo/canal: {group_username}\n")

    usar_cache = input("üì¶ Usar o levantamento anterior de arquivos (Enter ou S), ou n√£o, isto √©, atualizar a listagem de arquivos (N): ").strip().lower()
    if usar_cache in ['', 's'] and os.path.exists(CACHE_FILE):
        print("üóÇÔ∏è  Usando levantamento anterior.")
        with open(CACHE_FILE, 'r') as f:
            arquivos = json.load(f)
    else:
        print("üîÑ Atualizando levantamento de arquivos...")
        arquivos = await levantar_arquivos(client, group_username)

    termos = input("\nüîé Digite termos para busca (AND, OR, *, Enter p/ tudo): ").strip()
    arquivos_filtrados = [a for a in arquivos if combinar_nome(a['name'], termos)]
    print(f"\nüîç Arquivos encontrados com filtro: {len(arquivos_filtrados)}")

    try:
        if concurrent_downloads == 0:
            await asyncio.gather(*(baixar_arquivo(client, a, group_username, downloads_dir) for a in arquivos_filtrados))
        else:
            for i in range(0, len(arquivos_filtrados), concurrent_downloads):
                tarefas = arquivos_filtrados[i:i+concurrent_downloads]
                await asyncio.gather(*(baixar_arquivo(client, a, group_username, downloads_dir) for a in tarefas))
    except KeyboardInterrupt:
        print("\n‚õî Downloads interrompidos pelo usu√°rio.")

    print("\n‚úÖ Downloads conclu√≠dos.")

if __name__ == '__main__':
    try:
        thread_pular = threading.Thread(target=monitorar_pular_download, daemon=True)
        thread_pular.start()
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n‚õî Programa finalizado pelo usu√°rio com CTRL+C.")
